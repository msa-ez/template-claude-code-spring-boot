# Frontend Generation Rules

### Precautions
- All component generation must be based on metadata and must be generated without omissions. However, components should not be arbitrarily generated by referring to non-existent metadata.
- Favicon errors occur frequently and proactive measures should be taken in advance.

### Step-by-step Component Generation Process
The project must be generated strictly following the numbered sequence below.

#### 1. Metadata Analysis, Validation and Package Structure Generation
- Analyze aggregates, commands, readModels metadata
- Organize Pages, Modals, Services, Types, Stores, Hooks that need to be generated accordingly
- Correct missing package structure by referring to `@.claude/skills/react-frontend/references/package-structure.md`

#### 2. Generate Aggregate-related Components
- Generate hooks, services, store, types components under src directory
- After completion, generate Pages components with Grid Table structure that handle CRUD operation buttons, and API Endpoints must be generated according to `/aggregate.namePlural` rule
- For Page components, Buttons and Modals corresponding to CUD (Create, Update, Delete) operations must be generated based on aggregateRoot.fieldDescriptors metadata

#### 3. Generate Command-related Components
- Generate same number of Modal components as commands analyzed in Step 1
- Modal components must strictly comply with Command API Endpoints and HTML declared in each `BoundedContext/Aggregate/wireframe.md`
- After completing Modal component generation, all Modal components must be connected to `AggregatePage.tsx` in a structure that creates Buttons and calls Modals without omission
- Add API Endpoints to service layer and handle responses in HAL Spring Data REST format

#### 4. Generate ReadModel/View-related Components
- Generate same number of Search and Dashboard components as views analyzed in Step 1
- If `dataProjection: 'query-for-aggregate'` and `'queryParameters'` exist in metadata, generate Search component and connect to `AggregatePage.tsx`
- If `dataProjection: 'cqrs'` and `'fieldDescriptors'` exist in metadata, generate Dashboard component and connect to Sidebar in 2-level structure (Level 1 - 'Aggregate.name Dashboard', Level 2 - 'Dashboard.name')
- API Endpoints must be generated according to `/views.namePlural` rule

#### 5. Validate and Correct Routing and Endpoints
- Verify and correct if routing information connected to `AggregatePage.tsx` is configured as `/aggregate.namePlural`
- Verify and correct if CRUD API Endpoints declared in services follow REST API standards and are configured as `/aggregate.namePlural`
- Verify and correct if API Endpoints connected to `Modal.tsx` match API Endpoints declared in wireframes

#### 6. Environment Variables and Gateway Configuration
- Apply gateway folder directly if exists in Root; otherwise replace with md file
- Set `VITE_GATEWAY_URL=http://localhost:8088` in `.env`, `.env.development`, `.env.production`
- Specify Frontend route (localhost:3000) in gateway's `application.yaml` routes

#### 7. Resolve Critical Errors
- After completing metadata-based component generation, routing configuration, and environment variable setup, compare Command Modals verified in Step 3 with Commands called through Buttons in AggregatePage, then supplement missing Buttons and Modals.
- Compare ReadModel Dashboards verified in Step 4 with ReadModels connected to Sidebar, then supplement missing ReadModels.
- Then check and correct code or symptoms related to major error items documented in `@.claude/skills/react-frontend/references/troubleshooting.md` rules.
- Execute `npm run build` command to verify execution

### Important Requirements
- All component generation must be based on metadata. Components should not be arbitrarily generated by referring to non-existent metadata.
- Generate components only when required metadata fields exist
- Follow dependency order: Types → Services → Hooks → Components
- Favicon errors occur frequently and should be proactively addressed as a preventive measure
